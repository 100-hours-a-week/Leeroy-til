## 날짜: 2024-12-13

### 스크럼
- 학습 목표 1 : 컨테이너 클러스터 및 gh

## 주제 1:Github CLI 도구:gh

레포지토리 관리 , 이슈 , PR관리를 깃허브 웹사이트에서 하는것이 아닌 CLI환경에서 바로 해주는 도구

macOS 기준

```bash
brew install gh
```

설치 완료

<img width="561" alt="image (8)" src="https://github.com/user-attachments/assets/c1877149-d95e-40fc-9e7f-680cf5d5e319" />

Github CLI를 처음 이용시 내가 사용하고 싶은 github 계정에 로그인하는 과정을 가져야 한다.

```bash
gh auth login
```

설치 완료시 명령어로 로그인 상태를 확인할 수 있다.

<img width="565" alt="image (6)" src="https://github.com/user-attachments/assets/21d316b5-c2f1-4d13-82f6-8c4ff7365a2f" />

### 기본 명령어 모음

- **리포지토리 관련 명령**: `gh repo`
    - **`gh repo create`: 새로운 리포지토리 생성**
    - `gh repo clone`: 리포지토리 클론
    - `gh repo view`: 리포지토리 상세 보기
- **이슈 관련 명령**: `gh issue`
    - `gh issue list`: 이슈 목록 보기
    - `gh issue view`: 특정 이슈 상세 보기
    - `gh issue create`: 새로운 이슈 생성
    - `gh issue close`: 이슈 닫기
- **PR(Pull Request) 관련 명령**: `gh pr`
    - `gh pr list`: PR 목록 보기
    - `gh pr view`: 특정 PR 상세 보기
    - `gh pr create`: 새로운 PR 생성
- **Actions 관련 명령**: `gh run`, `gh workflow`
    - `gh run list`: 워크플로우 실행 목록 보기
    - `gh run watch`: 특정 워크플로우 실행 모니터링
    - `gh workflow view`: 워크플로우 상세 보기

### 터미널에서 바로 브라우저 열기

```bash
gh browse [<target>] [flags]
```

주요 옵션들

- **`-b`, `--branch string`: 특정 브랜치 페이지로 바로 이동할 때 사용.**
- `-c`, `--commit string[="last"]`: 커밋 SHA를 전달하여 다른 커밋 선택, 기본값은 마지막 커밋
- **`-R`, `--repo [HOST/]OWNER/REPO`: [HOST/]OWNER/REPO 형식을 사용하여 다른 리포지토리 선택**
- **`-s`, `--settings`: 리포지토리 설정 페이지 열기**

### 정리

- gh는 CLI환경에서도 github를 조작하게 해주는 도구이다.
- gh를 사용하면 레포지토리나 이슈 생성을 할때 편리하다.
- 터미널 같은 셸 환경의 특징은 텍스트 명령어로 기능을 수행 할 수 있다는 것
    - 즉, 예약된 명령어를 작성해도 작동한다는 것 ⇒ 자동화에 용이함
    - gh는 셸 환경에서 돌아가기 때문에 자동화에 용이하다.

## 클러스터
![image (7)](https://github.com/user-attachments/assets/0e31df94-d027-43a2-8290-b9c1dd61edd7)
<br>비슷한 것들이 오며 하나의 그룹을 이루는 집합

→ 여러대의 컴퓨터를 하나의 **네트워크로** 묶어 놓은 상태를 **하나의 클러스터** 라고 할 수 있음

### 작동 방법
- Node(노드):클러스트를 이루고 있는 각각의 컴퓨터 하나를 노드라고 부름
- 네트워크:노드간 통신을 가능하게 하는 로컬 네트워크가 존재함
- 마스터 노드: 외부에서 받은 요청을 로드 밸런서를 통하여 전달 받고 작업을 스케쥴링 하여 워커노드에게 할당함
- 워커 노드: 마스터 노드에게 받은 작업을 컨테이너가 실행하고 요청을 처리함

특징

각 노드들은 각자의 자체 운영체제 서비스를 운영

이러한 클러스터는 다양한 분야에 존재하며, 그 종류가 매우 많다.

ex) 컨테이너 클러스터, DB 클러스터, 로드밸런스 클러스터, IOT 클러스터 , 컴퓨터 클러스터 등등

위의 예시는 컴퓨터 클러스터를 기반으로 설명하였으며, 우리가 공부할 내용은 컨테이너 클러스터이다.

## 컨테이너 클러스터

컨테이너 클러스터를 알기위해 기존의 컨테이너만 사용하는 방식과 클러스터를 사용하는 방식을 비교해보자
<img width="497" alt="image (10)" src="https://github.com/user-attachments/assets/04f81fd4-00ee-4aaf-a413-e89639b2bd6e" />
<br>기존의 클러스터를 사용하지 않고 단일 호스트로 배포할 경우 **하나의 호스트에 모든 컨테이너**가 들어가 있다.

<img width="511" alt="image (9)" src="https://github.com/user-attachments/assets/b1056d58-dfd2-4513-b53c-2c29dc329606" />
<br>하지만 클러스터 방식은 여러개의 호스트가 존재하며, <strong>각 컨테이너를 여러 호스트에 분산하여 처리</strong>할 수 있다.

### 클러스터를 사용했을때 이점

- 확장성(Scale-out)
    - 필요에 따라 호스트를 여러개 늘리고 줄일 수 있다.
- 고가용성
    - 하나의 호스트가 문제가 생겨도 해당 컨테이너(작업)을 다른 호스트에 넘길 수 있어 서비스를 안정적으로 지속할 수 있다.
- 효율적 자원 관리
    - 클러스터 전제 자원을 통합적으로 관리하여 자원 할당·조정 작업을 직관적으로 가능하다.

즉, **컨테이너 클러스터는 여러개의 호스트를 하나의 통합된 가상 환경처럼 관리할 수 있게 하는것**

하지만 컨테이너의 갯수가 수백 수천개 라면? 일일이 관리하기 무척 힘들것이다.

이러한 클러스터 환경에서 효과적으로 관리하기 위해서는 **오케스트레이션**이 필요하다.

### 오케스트레이션

오케스트레이션 도구들은 클러스터 상태를 지속적으로 모니터링하고, 장애 및 스케일링 요구에 따라 자동으로 컨테이너를 재배치하거나 수를 조정하는 역할을 수행한다.


>💡<br>
위의 말을 쉽게 풀어쓴다면 문제점을 감지해서 자동으로 컨테이너도 살려주고.. 에러보고도 해주고.. 서버가 죽었으면 다른 서버에 역할 위임시켜서 자동으로 컨테이너 착착 배포해서 실행해주는 기능


이러한 컨테이너 오케스트레이션의 도구중 가장 유명한것이 k8s → kubernetes가 존재한다.

## k8s(Kubernetes)

오픈소스로 이루어진 컨테이너 오케스트레이션 플랫폼

Borg라는 Google에서 사용하는 내부 컨테이너 관리 시스템을 기반으로 만들어진것이 k8s

### 왜 사용할까?

**애플리케이션의 배포 및 관리의 복잡성의 증가!**

요즘은 단순히 하나의 서버에서 모든것을 관리하는 것이 아닌 **분산 시스템**으로 구성되어집니다.

때문에 배포 및 관리를 할때 신경써야 할 부분이 늘어나면 복잡성이 증가하게 되었습니다.

**분산 시스템**  덕분에 **확장성과** **가용성**면에서는 이득이지만 이를 관리하기 까다롭다는게 문제!!

### k8s를 썼을때 효과

- 컨테이너화된 애플리케이션의 자동 관리
    - 새 버전 배포시 수동 작업 없이 간단하게 업데이트 가능
    - 실패한 컨테이너를 자동으로 재시작
- 확장성
    - 사용량에 따라 컨테이너의 수를 자동으로 늘리고 줄이는 **Auto-scaling**을 지원
- 로드 밸런싱
    - 컨테이너의 트래픽을 분산하여 과부화 방지
- 고가용성 및 장애 복구
    - 컨테이너를 여러 노드에 배포하여 서버 장애가 발생하더라도 서비스가 중단되지 않게 함
    - 특정 노드가 다운이 되더라도 다른 노드에서 실행중인 동일 컨테이너를 통하여 서비스 제공이 가능함
- 배포 자동화
    - 롤링 업데이터 및 블루-그린 배포를 지원하여 서비스 중단 없이 새로운 버전을 업데이트가 가능함
    - 롤백 기능을 통하여 이전 상태로 복귀가 용이함
- 다양한 환경 지원
    - on-premise, **클라우드**, **하이브리드 환경** 등 어디에서나 실행 가능

| **특징** | **Kubernetes 없는 환경** | **Kubernetes 환경** |
| --- | --- | --- |
| **컨테이너 배포** | 수동으로 각 서버에 배포 | 자동화된 배포 |
| **확장성** | 수동으로 서버 추가 | 트래픽에 따라 자동 스케일링 |
| **장애 복구** | 장애 시 수동으로 서버 재구성 필요 | 자동으로 컨테이너 재시작 |
| **리소스 효율성** | 리소스 낭비 가능 | 효율적으로 리소스를 할당 및 조정 |
| **환경 간 일관성** | 개발 환경과 프로덕션 환경의 차이 있음 | 모든 환경에서 동일한 동작 |

k8s를 도입하면 효율적이고 안정적인 서비스 운영, 자동화된 배포 및 관리, 비용 최적화가 가능해집니다~